{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/* eslint-disable\n    @typescript-eslint/no-non-null-assertion,\n*/\nimport type { WorkerOptions } from 'node:worker_threads';\n\nimport { once } from 'node:events';\nimport { URL, pathToFileURL } from 'node:url';\nimport { Worker } from 'node:worker_threads';\nimport callsites from 'callsites';\n\ninterface WorkerData {\n    readonly parent?: string | URL | undefined;\n    readonly specifiers: readonly string[];\n}\n\nconst execArgv = Object.freeze([\n    ...new Set(process.execArgv)\n        .add('--experimental-import-meta-resolve')\n        .add('--no-warnings')\n]);\nconst isUrl = /^\\w+:\\/\\/.+/;\nconst thisUrl = import.meta.url;\nconst workerURL = createWorkerURL(workerContext);\n\n/**\n * Resolve a (single) module specifier.\n * @see [`import.meta.resolve`](https://nodejs.org/docs/latest-v18.x/api/esm.html#importmetaresolvespecifier-parent)\n * @param specifier The module specifier to resolve relative to `parent`.\n * @param parent    The absolute parent module URL to resolve from. (@defaultValue [`import.meta.url`](https://nodejs.org/docs/latest-v18.x/api/esm.html#importmetaurl))\n * @returns         A `Promise` that resolves to a module URL string.\n*/\nexport async function importMetaResolve(specifier: string, parent?: string | URL) {\n    const [result] = await importMetaResolveAll([specifier], parent);\n    return result!;\n}\n\n/**\n * Resolve multiple module specifiers with same `parent`.\n * @param iterable  An iterable (such as an array) of module specifiers to resolve relative to `parent`.\n * @param parent    The absolute parent module URL to resolve from. (@defaultValue [`import.meta.url`](https://nodejs.org/docs/latest-v18.x/api/esm.html#importmetaurl))\n * @returns         A `Promise` that resolves to an array of module URL strings.\n */\nexport async function importMetaResolveAll(iterable: Readonly<Iterable<string>>, parent?: string | URL) {\n    const specifiers = Array.isArray(iterable) ? iterable : [...iterable];\n    if (specifiers.length < 1) {\n        return [];\n    }\n    parent ??= getCallerUrl();\n    const workerData: WorkerData = { parent, specifiers };\n    const workerOptions = { execArgv, workerData } as WorkerOptions;\n    const worker = new Worker(workerURL, workerOptions);\n    try {\n        const [results] = await once(worker, 'message') as [string[]];\n        return results;\n    } catch (e) {\n        const { message, name } = Object(e) as Error;\n        throw Object.assign(new Error(message), { name });\n    } finally {\n        void worker.terminate();\n    }\n}\n\nfunction createWorkerURL(workerContextFunction: () => void | Promise<void>) {\n    const fText = workerContextFunction.toString();\n    const fBody = fText.slice(fText.indexOf('{') + 1, fText.lastIndexOf('}')).trim();\n    return new URL(`data:text/javascript,${encodeURIComponent(fBody)}`);\n}\n\nfunction getCallerUrl() {\n    for (const callSite of callsites()) {\n        const uri = callSite.getFileName();\n        if (uri) {\n            const url = isUrl.test(uri) ? uri : pathToFileURL(uri).href;\n            if (url !== thisUrl) {\n                return url;\n            }\n        }\n    }\n    return undefined;\n}\n\nasync function workerContext() {\n    const { parentPort, workerData } = await import('node:worker_threads'); // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n    const { parent, specifiers } = workerData as WorkerData;\n    const results = await Promise.all(specifiers.map(specifier => import.meta.resolve!(specifier, parent)));\n    parentPort!.postMessage(results);\n}\n"],"names":["execArgv","Object","freeze","Set","process","add","isUrl","thisUrl","import","meta","url","workerURL","createWorkerURL","workerContext","async","importMetaResolve","specifier","parent","result","importMetaResolveAll","iterable","specifiers","Array","isArray","length","getCallerUrl","workerData","workerOptions","worker","Worker","results","once","e","message","name","assign","Error","terminate","workerContextFunction","fText","toString","fBody","slice","indexOf","lastIndexOf","trim","URL","encodeURIComponent","callSite","callsites","uri","getFileName","test","pathToFileURL","href","undefined","parentPort","Promise","all","map","resolve","postMessage"],"mappings":"2JAeA,MAAMA,EAAWC,OAAOC,OAAO,IACxB,IAAIC,IAAIC,QAAQJ,UACdK,IAAI,sCACJA,IAAI,mBAEb,MAAMC,EAAQ,cACd,MAAMC,EAAUC,OAAOC,KAAKC,IAC5B,MAAMC,EAAYC,EAAgBC,GAS3BC,eAAeC,EAAkBC,EAAmBC,GACvD,MAAOC,SAAgBC,EAAqB,CAACH,GAAYC,GACzD,OAAOC,CACX,CAQOJ,eAAeK,EAAqBC,EAAsCH,GAC7E,MAAMI,EAAaC,MAAMC,QAAQH,GAAYA,EAAW,IAAIA,GAC5D,GAAIC,EAAWG,OAAS,EAAG,CACvB,MAAO,EACV,CACDP,IAAAA,EAAWQ,KACX,MAAMC,EAAyB,CAAET,SAAQI,cACzC,MAAMM,EAAgB,CAAE3B,WAAU0B,cAClC,MAAME,EAAS,IAAIC,EAAOlB,EAAWgB,GACrC,IACI,MAAOG,SAAiBC,EAAKH,EAAQ,WACrC,OAAOE,CAMV,CALC,MAAOE,GACL,MAAMC,QAAEA,EAAOC,KAAEA,GAASjC,OAAO+B,GACjC,MAAM/B,OAAOkC,OAAO,IAAIC,MAAMH,GAAU,CAAEC,QAC7C,CAAS,aACDN,EAAOS,WACf,CACL,CAEA,SAASzB,EAAgB0B,GACrB,MAAMC,EAAQD,EAAsBE,WACpC,MAAMC,EAAQF,EAAMG,MAAMH,EAAMI,QAAQ,KAAO,EAAGJ,EAAMK,YAAY,MAAMC,OAC1E,OAAO,IAAIC,EAAI,wBAAwBC,mBAAmBN,KAC9D,CAEA,SAAShB,IACL,IAAK,MAAMuB,KAAYC,IAAa,CAChC,MAAMC,EAAMF,EAASG,cACrB,GAAID,EAAK,CACL,MAAMxC,EAAMJ,EAAM8C,KAAKF,GAAOA,EAAMG,EAAcH,GAAKI,KACvD,GAAI5C,IAAQH,EAAS,CACjB,OAAOG,CACV,CACJ,CACJ,CACD,OAAO6C,SACX,CAEAzC,eAAeD,IACX,MAAM2C,WAAEA,EAAU9B,WAAEA,SAAqBlB,OAAO,uBAChD,MAAMS,OAAEA,EAAMI,WAAEA,GAAeK,EAC/B,MAAMI,QAAgB2B,QAAQC,IAAIrC,EAAWsC,KAAI3C,GAAaR,OAAOC,KAAKmD,QAAS5C,EAAWC,MAC9FuC,EAAYK,YAAY/B,EAC5B"}