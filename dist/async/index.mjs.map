{"version":3,"file":"index.mjs","sources":["../../src/async/index.ts"],"sourcesContent":["import type { WorkerOptions } from 'node:worker_threads';\nimport type { WorkerData } from './worker';\n\nimport { once } from 'node:events';\nimport { createRequire } from 'node:module';\nimport { Worker } from 'node:worker_threads';\nimport { execArgv, getCallerUrl } from '#_internal';\n\nconst baseUrl = import.meta.url;\nconst require = createRequire(baseUrl);\nconst workerPath = require.resolve('#worker/async');\n\n/**\n * Resolve a (single) module specifier.\n * @see [`import.meta.resolve`](https://nodejs.org/docs/latest-v18.x/api/esm.html#importmetaresolvespecifier-parent)\n * @param specifier The module specifier to resolve relative to `parent`.\n * @param parent    The absolute parent module URL to resolve from. (@defaultValue [`import.meta.url`](https://nodejs.org/docs/latest-v18.x/api/esm.html#importmetaurl))\n * @returns         A `Promise` that resolves to a module URL string.\n */\nexport async function importMetaResolve(specifier: string, parent?: string | URL): Promise<string> {\n    const [result] = await importMetaResolveAll([specifier], parent);\n    return result!; // eslint-disable-line @typescript-eslint/no-non-null-assertion\n}\n\n/**\n * Resolve multiple module specifiers with the same `parent`.\n * @param iterable  An iterable (such as an array) of module specifiers to resolve relative to `parent`.\n * @param parent    The absolute parent module URL to resolve from. (@defaultValue [`import.meta.url`](https://nodejs.org/docs/latest-v18.x/api/esm.html#importmetaurl))\n * @returns         A `Promise` that resolves to an array of module URL strings.\n */\nexport async function importMetaResolveAll(iterable: Readonly<Iterable<string>>, parent?: string | URL): Promise<string[]> {\n    const sources = Array.isArray(iterable) ? iterable as string[] : [...iterable];\n    if (sources.length < 1) {\n        return [];\n    }\n    const names = [...new Set(sources)]; // dedupe\n    parent ??= getCallerUrl(baseUrl);\n    const worker = new Worker(workerPath, {\n        execArgv,\n        workerData: { names, parent } satisfies WorkerData,\n    } as WorkerOptions);\n    try {\n        const [results] = await once(worker, 'message') as [string[]];\n        const urlMap = names.reduce((obj, name, i) => {\n            obj[name] = results[i]!;\n            return obj;\n        }, Object.create(null) as Record<string, string>);\n        return sources.map(name => urlMap[name]!);\n    } catch (e) {\n        const { message, name, stack } = Object(e) as Error;\n        throw Object.assign(new Error(), { message, name, stack });\n    } finally {\n        void worker.terminate();\n    }\n}\n"],"names":["baseUrl","require","createRequire","workerPath","importMetaResolve","specifier","parent","result","importMetaResolveAll","iterable","sources","names","getCallerUrl","worker","Worker","execArgv","results","once","urlMap","obj","name","i","e","message","stack"],"mappings":"oLAQA,MAAMA,EAAU,YAAY,IACtBC,EAAUC,EAAcF,CAAO,EAC/BG,EAAaF,EAAQ,QAAQ,eAAe,EASlD,eAAsBG,EAAkBC,EAAmBC,EAAwC,CAC/F,KAAM,CAACC,CAAM,EAAI,MAAMC,EAAqB,CAACH,CAAS,EAAGC,CAAM,EAC/D,OAAOC,CACX,CAQA,eAAsBC,EAAqBC,EAAsCH,EAA0C,CACvH,MAAMI,EAAU,MAAM,QAAQD,CAAQ,EAAIA,EAAuB,CAAC,GAAGA,CAAQ,EAC7E,GAAIC,EAAQ,OAAS,EACjB,MAAO,CAAC,EAEZ,MAAMC,EAAQ,CAAC,GAAG,IAAI,IAAID,CAAO,CAAC,EAClCJ,IAAWM,EAAaZ,CAAO,EAC/B,MAAMa,EAAS,IAAIC,EAAOX,EAAY,CAClC,SAAAY,EACA,WAAY,CAAE,MAAAJ,EAAO,OAAAL,CAAO,CAChC,CAAkB,EAClB,GAAI,CACA,KAAM,CAACU,CAAO,EAAI,MAAMC,EAAKJ,EAAQ,SAAS,EACxCK,EAASP,EAAM,OAAO,CAACQ,EAAKC,EAAMC,KACpCF,EAAIC,CAAI,EAAIJ,EAAQK,CAAC,EACdF,GACR,OAAO,OAAO,IAAI,CAA2B,EAChD,OAAOT,EAAQ,IAAIU,GAAQF,EAAOE,CAAI,CAAE,CAC5C,OAASE,EAAG,CACR,KAAM,CAAE,QAAAC,EAAS,KAAAH,EAAM,MAAAI,CAAM,EAAI,OAAOF,CAAC,EACzC,MAAM,OAAO,OAAO,IAAI,MAAS,CAAE,QAAAC,EAAS,KAAAH,EAAM,MAAAI,CAAM,CAAC,CAC7D,QAAA,CACSX,EAAO,UAAA,CAChB,CACJ"}